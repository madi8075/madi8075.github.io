<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            stone,
            zinc
          }
        }
      }
    }
  </script>
</head>

<body>
  <!--
    Madi's Code Portfolio 2023
  -->
  <div class="relative flex min-h-screen flex-col overflow-hidden bg-neutral-900 py-6 sm:py-12">
    <div class="top-0 mb-20 z-10 h-16 pt-6">
      <div class="sm:px-8 top-[var(--header-top,theme(spacing.6))] w-full">
        <div class="mx-auto max-w-7xl lg:px-8">
          <div class="relative px-4 sm:px-8 lg:px-12">
            <div class="mx-auto max-w-2xl lg:max-w-5xl">
              <div class="relative flex gap-4">
                <div class="flex flex-1">
                  <div class="h-14 w-14 rounded-sm p-0.5">
                    <a aria-label="Home" class="pointer-events-auto" href="/"><img alt="" src="img/emblem.svg"
                        width="512" height="512" decoding="async" data-nimg="1" class="object-cover h-auto w-auto"
                        style="color: transparent;"></a></div>
                </div>
                <div class="flex flex-1 items-center justify-end md:justify-center">
                  <!--<div class="pointer-events-auto md:hidden" data-headlessui-state=""><button
                      class="group flex items-center rounded-full bg-white/90 px-4 py-2 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10 dark:hover:ring-white/20"
                      type="button" aria-expanded="false" data-headlessui-state=""
                      id="headlessui-popover-button-:R2qb6:">Menu<svg viewBox="0 0 8 6" aria-hidden="true"
                        class="ml-3 h-auto w-2 stroke-zinc-500 group-hover:stroke-zinc-700 dark:group-hover:stroke-zinc-400">
                        <path d="M1.75 1.75 4 4.25l2.25-2.5" fill="none" stroke-width="1.5" stroke-linecap="round"
                          stroke-linejoin="round"></path>
                      </svg></button></div>-->
                  <nav class="pointer-events-auto stroke md:block">
                    <ul
                      class="flex rounded-full bg-white/90 px-3 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10">
                      <li><a class="relative block px-3 py-2 transition hover:text-yellow-500 dark:hover:text-yellow-400"
                          href="/">About Me
                        </a>
                      </li>
                      <li><a
                          class="relative block px-3 py-2 transition text-yellow-500 dark:text-yellow-400"
                          href="/portfolio.html">Code Portfolio
                          <span class="absolute inset-x-1 -bottom-px h-px bg-gradient-to-r from-yellow-500/0 via-yellow-500/40 to-yellow-500/0 dark:from-yellow-400/0 dark:via-yellow-400/40 dark:to-yellow-400/0"></span>
                        </a></li>
                      <li><a
                          class="relative block px-3 py-2 transition hover:text-yellow-500 dark:hover:text-yellow-400"
                          href="/contact.html">Contact</a></li>
                    </ul>
                  </nav>
                </div>
                <div class="flex justify-end md:flex-1">
                  <div class="pointer-events-none">
                    <button type="button" aria-label="Toggle dark mode"
                      class="group px-3 py-2 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur transition"><svg
                        viewBox="0 0 24 24" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"
                        aria-hidden="true"
                        class="h-6 w-6 fill-zinc-100 stroke-zinc-500 transition group-hover:fill-zinc-200 group-hover:stroke-zinc-700 dark:hidden [@media(prefers-color-scheme:dark)]:fill-yellow-50 [@media(prefers-color-scheme:dark)]:stroke-yellow-500 [@media(prefers-color-scheme:dark)]:group-hover:fill-yellow-50 [@media(prefers-color-scheme:dark)]:group-hover:stroke-yellow-600">
                        <path
                          d="M8 12.25A4.25 4.25 0 0 1 12.25 8v0a4.25 4.25 0 0 1 4.25 4.25v0a4.25 4.25 0 0 1-4.25 4.25v0A4.25 4.25 0 0 1 8 12.25v0Z">
                        </path>
                        <path
                          d="M12.25 3v1.5M21.5 12.25H20M18.791 18.791l-1.06-1.06M18.791 5.709l-1.06 1.06M12.25 20v1.5M4.5 12.25H3M6.77 6.77 5.709 5.709M6.77 17.73l-1.061 1.061"
                          fill="none"></path>
                      </svg><svg viewBox="0 0 24 24" aria-hidden="true"
                        class="hidden h-6 w-6 fill-zinc-700 stroke-zinc-500 transition dark:block [@media(prefers-color-scheme:dark)]:group-hover:stroke-zinc-400 [@media_not_(prefers-color-scheme:dark)]:fill-yellow-400/10 [@media_not_(prefers-color-scheme:dark)]:stroke-yellow-500">
                        <path
                          d="M17.25 16.22a6.937 6.937 0 0 1-9.47-9.47 7.451 7.451 0 1 0 9.47 9.47ZM12.75 7C17 7 17 2.75 17 2.75S17 7 21.25 7C17 7 17 11.25 17 11.25S17 7 12.75 7Z"
                          stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
                      </svg></button></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="relative px-4 sm:px-8 lg:px-12">
      <div class="mx-auto max-w-2xl lg:max-w-5xl">

        <!-- <div class="grid grid-cols-1 gap-y-16 lg:grid-cols-2 lg:grid-rows-[auto_1fr] lg:gap-y-12">
          
        </div> -->
        <!-- short form content section -->
        <div class="overflow-hidden py-4 sm:py-6 space-y-24">

  <!-- PROJECT 1 -->
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto grid max-w-2xl grid-cols-1 gap-y-16 gap-x-8 sm:gap-y-20 lg:mx-0 lg:max-w-none lg:grid-cols-2">
      <div class="lg:ml-auto lg:pt-4 lg:pl-4">
        <div class="lg:max-w-lg">
          <h2 class="text-xl font-semibold leading-7 text-yellow-500">Java</h2>
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-100 sm:text-4xl">SneakyQueens</p>
          <p class="mt-6 text-lg leading-8 text-gray-300">
            I was tasked with returning if any of the queens can attack each other on a chess board. I had to solve the math problem for the rows and be careful of time/space complexity.</p>
          <dl class="mt-10 max-w-xl space-y-8 text-base leading-7 text-gray-600 lg:max-w-none">
            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor" aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                How I solved this: 
              </dt>
              <dd class="inline text-gray-400"> Hashsets to store rows, columns, and diagonals as unsafe as each queen is processed. Horner's rule to do math on the rows and columns.</dd>
            </div>

            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                Input: 
              </dt>
              <dd class="inline text-gray-400">File full of only queen positions, with the characters regarding the rows and numbers for the columns. The dimensions could be up to 60,000 for each side.</dd>
            </div>
          </dl>
        </div>
      </div>
  
      <!-- tiny slot-->
      <pre class="w-full overflow-hidden max-w-5xl text-sm mx-auto">
        <!-- change language-java to language-x -->
        <code class="language-java rounded-lg code bg-gray-800" style="height: 37rem">
import java.util.*;

public class SneakyQueens
{
  public static boolean allTheQueensAreSafe(ArrayList<String> coordinateStrings, int boardSize)
  {
    // Main boolean and hashsets for spaces that are not safe
    boolean safe = true;
    HashSet &lt;Integer&gt; unsafeRow = new HashSet &lt;Integer&gt;();
    HashSet &lt;Integer&gt; unsafeCol = new HashSet &lt;Integer&gt;();
    HashSet &lt;Integer&gt; unsafeDiag = new HashSet &lt;Integer&gt;();
    HashSet &lt;Integer&gt; unsafeDiagNeg = new HashSet&lt;Integer&gt;();
    HashSet &lt;Integer&gt; unsafeDiagB = new HashSet&lt;Integer&gt;();

    // Loop through each queen in the array list
    for (int i = 0; i < coordinateStrings.size(); i++)
    {
      // Declarations, mult used for horner's rule and isChar when we hit columns
      int length = (coordinateStrings.get(i)).length();
      int row = 0;
      int column = 0;
      boolean isChar = false;
      int mult = 1; // Loop through the string backwards to use horner's rule
      for (int j = length - 1; j >= 0; j--)
      {
          char current = (coordinateStrings.get(i)).charAt(j);
          int currInt = (int) current;

          // Hit the end of our row, mark it unsafe. If the queen can be attacked, return
          if (currInt >= 'a' && !isChar)
          {
            isChar = true;
            mult = 1;
            safe = markUnsafe(unsafeRow, row);
            if(!safe)
                return safe;
          }
          if (!isChar)
          {
            currInt -= '0';
            row += currInt * mult;
            mult *= 10;
          }
          // Change char to correct int, horner's rule
          else if (isChar)
          {
            currInt -= 'a' - 1;
            column += currInt * mult;

            // End of string, mark diagonals that are not safe and check if this queen is
            if(j == 0)
            {
              safe = markUnsafe(unsafeCol, column);
              if (!safe)
                return safe;
              safe = unsafeDiagB(unsafeDiagB, row, column);
              if (!safe)
                return safe;
              safe = unsafeDiag(unsafeDiag, unsafeDiagNeg, row, column);
              if (!safe)
                return safe;
            }
          mult *= 26;
          }
        }
      }
    return safe;
  }

  // Helper method to mark the rows and columns as unsafe. .contains for hashset is O(1)
  private static boolean markUnsafe(HashSet<Integer> unsafe, int value)
  {
    boolean safe = true;
    if(!(unsafe.contains(value)))
      unsafe.add(value);
    else if(unsafe.contains(value))
      safe = false;
  return safe;
  }

  private static boolean unsafeDiag(HashSet<Integer> pos, HashSet<Integer> neg, int row, int col)
  {
    int diag = 0;

    // Formula to check mark diag unsafe, avoiding negative ints
    if(col <= row)
    { 
      diag=row - col; if(pos.contains(diag)) return false; pos.add(diag);
    }
    else if (col > row)
    {
      diag = col - row;
      if(neg.contains(diag))
        return false;
      neg.add(diag);
    }
    return true;
  }

  // Function for other diag plane
  private static boolean unsafeDiagB(HashSet<Integer> diagB, int row, int col)
  {
    int diag = row + col;

    if (diagB.contains(diag))
      return false;
    diagB.add(diag);
    return true;

  }
}
        </code>
      </pre>
      
      <!-- end tiny slot -->
      
    </div>
  </div>
  <!-- END PROJECT 1 -->

  <!-- PROJECT 2 -->
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto grid max-w-2xl grid-cols-1 gap-y-16 gap-x-8 sm:gap-y-20 lg:mx-0 lg:max-w-none lg:grid-cols-2">
       <!-- tiny slot-->
       <pre class="w-full overflow-hidden max-w-5xl text-sm mx-auto">
        <!-- change language-java to language-x -->
        <code class="language-java rounded-lg code bg-gray-800" style="height: 37rem">
import java.util.*;
import java.lang.Math;

public class RunLikeHell
{
    public static int maxGain (int [] blocks)
    {
        int memo[] = new int[blocks.length];

        // No need to go through a loop if there are 3 blocks or less
        if (blocks.length <= 3)
        {
            if (blocks.length == 3)
                return Math.max(blocks[0] + blocks[2], blocks[1]);
            else if (blocks.length == 2)
                return Math.max(blocks[0], blocks[1]);
            else if (blocks.length == 1)
                return blocks[0];
            else if (blocks.length == 0)
                return 0;
        }

        // Set the first 3 blocks, as 0 and 1 will not have addition & slot 3 only has 1 answer
        memo[0] = blocks[0];
        memo[1] = blocks[1];
        memo[2] = blocks[0] + blocks[2];


        // Loop through the blocks. We test to see if it is better to add the math from 2 away
        // Or if we should check the previous one. Each memo entry holds the math up to this point
        for (int i = 3; i < blocks.length; i++)
            memo[i] += blocks[i] + Math.max(memo[i - 2], memo[i - 3]);

        // Compare to see if the last block or one before is better, in case the last is small
        return Math.max(memo[blocks.length - 1], memo[blocks.length - 2]);
    }
}
        </code>
      </pre>

       <!-- end tiny slot -->
      <div class="lg:ml-auto lg:pt-4 lg:pl-4">
        <div class="lg:max-w-lg">
          <h2 class="text-xl font-semibold leading-7 text-yellow-500">Java</h2>
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-100 sm:text-4xl">RunLikeHell</p>
          <p class="mt-6 text-lg leading-8 text-gray-300">
            Find the optimal path for a person to take to maximize the sum. No two numbers could be touched in a row, and sometimes it was worth skipping more than one number. This was meant to be done in O(n) time with a dynamic programming solution.</p>
          <dl class="mt-10 max-w-xl space-y-8 text-base leading-7 text-gray-600 lg:max-w-none">
            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                How I solved this:
              </dt>
              <dd class="inline text-gray-400">I used a simple solution with dynamic programming to store the previous best options per block.</dd>
            </div>

            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                Input:
              </dt>
              <dd class="inline text-gray-400">An int array was passed through containing the block values in order.</dd>
            </div>
          </dl>
        </div>
      </div>

    </div>
  </div>

  <!-- END PROJECT 2 -->
  
  <!-- PROJECT 3 -->
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto grid max-w-2xl grid-cols-1 gap-y-16 gap-x-8 sm:gap-y-20 lg:mx-0 lg:max-w-none lg:grid-cols-2">
      <div class="lg:ml-auto lg:pt-4 lg:pl-4">
        <div class="lg:max-w-lg">
          <h2 class="text-xl font-semibold leading-7 text-yellow-500">C</h2>
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-100 sm:text-4xl">Checksum Processing</p>
          <p class="mt-6 text-lg leading-8 text-gray-300">
            Calculate the checksum for a text in a file. Size could be 8, 16, or 32.</p>
          <dl class="mt-10 max-w-xl space-y-8 text-base leading-7 text-gray-600 lg:max-w-none">
            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                How I solved it:
              </dt>
              <dd class="inline text-gray-400">Added padding if uneven number of characters, then did bitwise operations to get the checksum.</dd>
            </div>

            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                Input:
              </dt>
              <dd class="inline text-gray-400">A file with the name of the input file and the checksum size. Then process the input file accordingly.</dd>
            </div>
          </dl>
        </div>
      </div>

      <!-- tiny slot-->
      <pre class="w-full overflow-hidden max-w-5xl text-sm mx-auto">
        <!-- change language-java to language-x -->
        <code class="language-c rounded-lg code bg-gray-800" style="height: 37rem">
  #include &lt;math.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;time.h&gt;
  #include &lt;stdio.h&gt;

  int printInput(FILE *fptr, int checkSumSize, char inputArr[]);
  void calcCheckSum(int checkSumSize, char inputArr[], int size);


  int main(int argc, char *argv[])
  {
    // Copy the name of the file, open it, and check to make sure it is not NULL
    char *fName = malloc(sizeof(char) * 20);
    fName = argv[1];

    FILE *in = fopen(fName, "r");
    char ch;
    int count = 0;
    while((ch = fgetc(in)) != EOF)
    {
      count++;
    }

    rewind(in);
    count += 3;
    // To account for XXX padding in 32 bit.
    // Count is only used to malloc the input array in case he throws a curve ball with the array size
    char *inputArr = malloc(sizeof(char)*count);


    if(in == NULL)
    {
    printf("File is NULL"); //used for testing, comment out later
    exit(1);
    }

    //Convert the 2nd argument to int to use as bit size for checksum & verify it is a valid size
    int checkSumSize = atoi(argv[2]);

    if(checkSumSize != 8 && checkSumSize != 16 && checkSumSize != 32)
    {
    fprintf(stderr, "Valid checksum sizes are 8, 16, or 32\n");
    }

    int size = 0;
    size = printInput(in, checkSumSize, inputArr);
    calcCheckSum(checkSumSize, inputArr, size);

    fclose(in);
    return 0;

  }

  int printInput(FILE *fptr, int checkSumSize, char inputArr[])
  {
    char curr; //reading 1 char at a time
    int size = 0;
    printf("\n");
    // starting new line because for some reason his outputs have it. doesn't pass the bash test without this

    while(curr != EOF)
    {
      curr = fgetc(fptr);
      printf("%c", curr); // printing output
      // Setting up the array for later use
      inputArr[size] = curr;

      if((size + 1) % 80 == 0)
      printf("\n");

      size++;
      // Terminating char
      if(curr == '\n')
        break;
      }

      return size;
    }

  void calcCheckSum(int checkSumSize, char inputArr[], int size)
  {
    int j = 0;
    // checksum
    unsigned int long sum = 0;
    unsigned int long a = 0; // value for current unsigned int to add to checksum
    switch (checkSumSize) {
      case 8:
       for(j = 0; j < size; j++) 
       {
          a = inputArr[j];
          sum +=a;
        }
        sum = sum << 56;
        sum = sum >> 56;
        break;

      case 16:
        if(size%2 != 0)
        {
          // Padding if uneven chars
          inputArr[size] = 'X';
          printf("X");
          size++;
        }

        // Adding to checksum and shifting the bits each time
        for(j = 0; j < size; j++)
        {
          a=inputArr[j];
          a=a<<8;
          a += inputArr[j+1];
          sum += a;
          a=0; // Reset the operand
          j++;
        }
        sum = sum << 48;
        sum = sum >> 48; // deleting carry
        break;

      case 32:
        while(size%4 != 0)
        {
          inputArr[size] = 'X'; // looping the pad
          printf("X");
          size++; // adjusting size for pad
        }

        for(j = 0; j < size; j++)
        {
          for(int i = 0; i < 4; i++)
          {
            a = (a << 8) + inputArr[j + i]; // add and shift each time
          }
          sum += a;
          a = 0;
          j += 3;
        }
        sum = sum << 32;
        sum = sum >> 32;
        break;
      }
      printf("\n%2d bit checksum is %8lx for all %4d chars\n",checkSumSize, sum, size);
      return;
    }
        </code>
      </pre>

      <!-- end tiny slot -->

    </div>
  </div>
  <!-- END PROJECT 3 -->

  <!-- PROJECT 4 -->
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto grid max-w-2xl grid-cols-1 gap-y-16 gap-x-8 sm:gap-y-20 lg:mx-0 lg:max-w-none lg:grid-cols-2">
       <!-- tiny slot-->
       <pre class="w-full overflow-hidden max-w-5xl text-sm mx-auto">
        <!-- change language-java to language-x -->
        <code class="language-c rounded-lg code bg-gray-800" style="height: 37rem">

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_STACK_HEIGHT 2048
#define MAX_CODE_LENGTH 512

char names[][28] = {"LIT", "RTN", "CAL", "POP", "PSI", "PRM", "STO",
                      "INC", "JMP", "JPC", "CHO", "CHI", "HLT", "NDB",
                      "NEG", "ADD", "SUB", "MUL", "DIV", "MOD", "EQL",
                      "NEQ", "LSS", "LEQ", "GTR", "GEQ", "PSP"};
void hasTwoValues(int SP);
void checkInvariants(int BP, int SP, int PC);

int main(int argc, char *argv[]) {
    int opCode, m;
    int BP = 0, SP = BP, PC = BP;
    int index = 0;

    int stack[MAX_STACK_HEIGHT];
    int opCodeValues[MAX_CODE_LENGTH];
    int mValues[MAX_CODE_LENGTH];

    FILE* file;

    file = fopen(argv[1], "r");

    while(fscanf(file, "%d %d", &opCode, &m) != EOF) {
        opCodeValues[index] = opCode;
        mValues[index] = m;

        if(!index)
            printf("Addr\tOP\tM\n");
        
        printf("%d\t%s\t%d\n", index, names[opCode - 1], m);
        index++;
    }

    fclose(file);

    int debug = 1;
    // Run the until file ends
    printf("Tracing...\nPC: 0 BP: 0 SP: 0\nstack: \n");

    for(int i = 0; i < index; i++)
    {
      checkInvariants(BP, SP, PC);

        PC++;

        if(debug)
            printf("==> addr: %d\t%s\t%d\n", i, names[opCodeValues[i] - 1], mValues[i]);

        switch (opCodeValues[i]) {
            // Push a literal
            case 1: // LIT
                stack[SP] = mValues[i];
                SP++;
                break;
            case 2: // RTN
                hasTwoValues(SP);
                PC = stack[SP - 1];
                i = PC-1;
                BP = stack[SP - 2];
                SP = SP - 2;
                break;
            case 3: // CAL
                stack[SP] = BP; // dynamic link
                stack[SP + 1] = PC;
                BP = SP;
                SP = SP + 2;
                PC = mValues[i];
                i = PC-1;
                break;
            case 4: // POP
                if (SP == 0) {
                  printf("error\n");
                  fflush(stdout);
                  fprintf(stderr, "Trying to pop an empty stack!");
                  exit(1);
                }
                SP = SP - 1;
                break;
            case 5: // PSI
                stack[SP - 1] = stack[stack[SP - 1]];
                break;
            case 6: //PRM
                stack[SP] = stack[BP - mValues[i]];
                SP++;
                break;
            case 7: // STOP
                stack[stack[SP - 1] + mValues[i]] = stack[SP - 2];
                SP = SP - 2;
                break;
            case 8: // INC
                SP = SP + mValues[i];
                break;
            case 9: //JMP
                PC = stack[SP - 1];
                i = PC - 1;
                SP--;
                break;
            case 10: // JPC
                if (stack[SP - 1] != 0)
                {
                    PC = mValues[i];
                    i = PC - 1;
                }
                SP--;
                break;
            case 11: // CHO
                if (SP == 0) {
                  fprintf(stderr, "Stack is empty!");
                  exit(1);
                }
                putc(stack[SP - 1], stdout);
                SP--;
                break;
            case 12: // CHI
                // If EOF or error, should store -1
                stack[SP] = getc(stdin);
                SP--;
                break;
            case 13: // HLT
                if(debug)
                {
                    printf("PC: %d BP: %d SP: %d\nstack: ", PC, BP, SP);
                    // Print the stack
                    for (int j = 0; j < SP; j++)
                        printf("S[%d]: %d ", j, stack[j]);
                    printf("\n");
                }
                exit(0);
                break;
            case 14: // NDB
                debug = 0;
                break;
            case 15: // NEG
                stack[SP - 1] *= -1;
                break;
            case 16: // ADD
                hasTwoValues(SP);
                stack[SP - 2] = stack[SP - 1] + stack[SP - 2];
                SP--;
                break;
            case 17: // SUB
                hasTwoValues(SP);
                stack[SP - 2] = stack[SP - 1] - stack[SP - 2];
                SP--;
                break;
            case 18: // MUL
                hasTwoValues(SP);
                stack[SP - 2] = stack[SP - 1] * stack[SP - 2];
                SP--;
                break;
            case 19: // DIV
                hasTwoValues(SP);
                if(stack[SP - 2] == 0)
                    {
                        fflush(stdout);
                        fprintf(stderr, "Divisor is zero in DIV instruction!");
                        exit(1);
                    }
                stack[SP - 2] = stack[SP - 1] / stack[SP - 2];
                SP--;
                break;
            case 20: // MOD
                hasTwoValues(SP);
                if(stack[SP - 2] == 0)
                {
                    fflush(stdout);
                    fprintf(stderr, "Modulus is zero in MOD instruction!");
                    exit(1);
                }
                stack[SP - 2] = stack[SP - 1] % stack[SP - 2];
                SP--;
                break;
            case 21: // EQL
                hasTwoValues(SP);
                stack[SP - 2] = (stack[SP - 1] == stack[SP - 2]);
                SP--;
                break;
            case 22: // NEQ
                hasTwoValues(SP);
                stack[SP - 2] = !(stack[SP - 1] == stack[SP - 2]);
                SP--;
                break;
            case 23: // LSS
                hasTwoValues(SP);
                stack[SP - 2] = (stack[SP - 1] < stack[SP - 2]);
                SP--;
                break;
            case 24: // LEQ
                hasTwoValues(SP);
                stack[SP - 2] = (stack[SP - 1] <= stack[SP - 2]);
                SP--;
                break;
            case 25: // GTR
                hasTwoValues(SP);
                stack[SP - 2] = (stack[SP - 1] > stack[SP - 2]);
                SP--;
                break;
            case 26: // GEQ
                hasTwoValues(SP);
                stack[SP - 2] = (stack[SP - 1] >= stack[SP - 2]);
                SP--;
                break;
            case 27: // PSP
                stack[SP] = SP;
                SP++;
                break;
            default:
                printf("Error: %d was not a valid instruction.", opCodeValues[i]);
                break;
        }


            if(debug)
            {
              printf("PC: %d BP: %d SP: %d\nstack: ", PC, BP, SP);
              // Print the stack
              for (int j = BP; j < SP; j++)
                  printf("S[%d]: %d ", j, stack[j]);
              printf("\n");
            }

    }

    return 0;
}

void hasTwoValues(int SP) {
  if (SP < 2) {
    fflush(stdout);
    fprintf(stderr, "Trying to pop an empty stack!");
    exit(1);
  }
}

void checkInvariants(int BP, int SP, int PC) {
    if(!(0 <= BP && BP <= SP && SP < MAX_STACK_HEIGHT))
    {
        fprintf(stderr, "Invariant Error!");
        exit(1);
    }
    if(!(0 <= PC && PC < MAX_CODE_LENGTH))
    {
        fprintf(stderr, "Invariant Error!");
        exit(1);
    }
}

int isFull(int SP) {
  if (SP == MAX_STACK_HEIGHT)
    return 1;
  else
    return 0;
}

int isEmpty(int SP) {
  if (SP == 0)
    return 1;
  else
    return 0;
}
        </code>
      </pre>

       <!-- end tiny slot -->
      
      <div class="lg:ml-auto lg:pt-4 lg:pl-4">
        <div class="lg:max-w-lg">
          <h2 class="text-xl font-semibold leading-7 text-yellow-500">C</h2>
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-100 sm:text-4xl">Stack Machine</p>
          <p class="mt-6 text-lg leading-8 text-gray-300">Group project to create a stack machine. This was made between a group of 3 people, including myself. This project gave me an appreciation for clear code with good comments when working apart from others, as when one made a change it could get confusing.
          </p>
          <dl class="mt-10 max-w-xl space-y-8 text-base leading-7 text-gray-600 lg:max-w-none">
            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                How we solved it:
              </dt>
              <dd class="inline text-gray-400">Took the opcode in and used a switch statement depending on what machine command was run. Kept track of the stack pointer, program counter, and the break pointer. Also kept a debugging log of the stack at each command..</dd>
            </div>

            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                Input: 
              </dt>
              <dd class="inline text-gray-400">The opcode and m code for each command was read in and processed while the program ran.</dd>
            </div>

            <!--<div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
              </dt>
              <dd class="inline text-gray-400"></dd>-->
            </div>
          </dl>
        </div>
      </div>

    </div>
  </div>
  <!-- END PROJECT 4 -->
  
  <!-- PROJECT 5 -->
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto grid max-w-2xl grid-cols-1 gap-y-16 gap-x-8 sm:gap-y-20 lg:mx-0 lg:max-w-none lg:grid-cols-2">
      <div class="lg:ml-auto lg:pt-4 lg:pl-4">
        <div class="lg:max-w-lg">
          <h2 class="text-xl font-semibold leading-7 text-yellow-500">C</h2>
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-100 sm:text-4xl">Akcija Kattis Project</p>
          <p class="mt-6 text-lg leading-8 text-gray-300">
            Buy two get one free deal at a bookstore. Find the best deal possible for the customer.
          </p>
          <dl class="mt-10 max-w-xl space-y-8 text-base leading-7 text-gray-600 lg:max-w-none">
            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                How I solved it:
              </dt>
              <dd class="inline text-gray-400">Ran either quick sort or merge sort depending on how many items we were dealing with. Then looped backwards to always get the most expensive possible book for free.</dd>
            </div>

            <div class="relative pl-9">
              <dt class="inline font-semibold text-gray-200">
                <svg class="absolute top-2.5 left-1 h-2 w-2 text-yellow-600" viewBox="0 0 100 100" fill="currentColor"
                  aria-hidden="true">
                  <circle cx="50" cy="50" r="50" />
                </svg>
                Input:
              </dt>
              <dd class="inline text-gray-400">Text file given the number of books and the prices of each book. It could be a very large amount of books, hence the reason for 2 different sorts.</dd>
            </div>

            <div class="relative pl-9">
              <a class="group flex text-align font-medium text-gray-800 transition hover:text-yellow-500 dark:text-gray-200 dark:hover:text-yellow-500"
                href="https://open.kattis.com/problems/akcija" target="_blank"><svg viewBox="0 0 24 24"
                  aria-hidden="true"
                  class="h-6 w-6 flex-none fill-gray-500 transition group-hover:fill-yellow-500">
                  
                </svg><span class="ml-4">Click me for info!</span></a>
          </dl>
        </div>
      </div>

      <!-- tiny slot-->
      <pre class="w-full overflow-hidden max-w-5xl text-sm mx-auto">
        <!-- change language-java to language-x -->
        <code class="language-c rounded-lg code bg-gray-800" style="height: 37rem">
  #include &lt;math.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;time.h&gt;
  #include &lt;stdio.h&gt;

  // Function declarations so they can be put after main for clean code:
  void swap(int *a, int *b); // Swap values during quick Sort
  int partition(int *values, int low, int high);
  void quickSort (int *bookList, int low, int high); // Quick sort to be used on smaller number of books
  void calcPrice(int bookList[]); // Function to calculate and print the price of the books at the end
  void mergeSort(int values[], int start, int end); // Function to merge sort the values for easier calculation with larger numBooks
  void merge(int values[], int start, int middle, int end); // Merge function to be used during the merge sort


  int numBooks = 0; // Number of books, will be used throughout code and will not change.

  int main()
  {
    if(scanf("%d", &numBooks) == 1); // Check input value is entered for kattis acception
    int *bookList = (int*) malloc(numBooks * sizeof(int)); // Dynamically allocated array depending on the numBooks

    for (int i = 0; i < numBooks; i++)
    {
      if(scanf("%d", &bookList[i]) == 1); // Read in each price of the books
    }
    if(numBooks < 1000)
      quickSort(bookList, 0, numBooks - 1); // Quick sort if smaller number of books for shorter run time.
    else
      mergeSort(bookList, 0, numBooks - 1); // Merge sort larger number of books because it is constant O(nlogn) rather than quick sort's worst case O(n^2)
    
    calcPrice(bookList); // Calculate the price and print result
    free(bookList); // Free the memory used
    return 0;
  }
  
  int isSorted(int books[], int low, int high)
  { 
    // check if the array is already sorted
    for(int i = low; i < high - 1; i++)
    {
      if(books[i] > books[i + 1])
        return 0;
    }
    return 1;
  }

  // Swap 2 indexes in the array during quick sort
  void swap(int *a, int *b)
  {
    int temp = *a;
    *a = *b;
    *b = temp;
  }

  int partition(int *values, int low, int high)
  {
    int temp, i, lowPos;

    i = low + rand()%(high - low + 1); // using a random partition helps to bring down the runtime of the code.
    swap(&values[low], &values[i]); // swap the random partition into low to use as a starting pivot

    lowPos = low;
    low++; // because it has been swapped.

    while(low <= high)
    {
      while(low <= high && values[low] <= values[lowPos])
        low++; // find the next lowest position in the wrong place.
      while(high >= low && values[high] > values[lowPos])
        high--; // find the next highest value in the wrong place.
      if (low < high)
        swap(&values[low], &values[high]); // swap the values
    }
    
    swap(&values[lowPos], &values[high]); // put partition value into the right place
    return high; // index of partition element
  }

  void quickSort (int *bookList, int low, int high)
  {
    if(low < high)
    {
      int split=partition(bookList, low, high); // this is where we make our swaps for the sort
      quickSort(bookList, low, split-1); // continue partitioning recursively
      quickSort(bookList, split+1, high);
    }
  }
  
  void calcPrice(int *bookList)
  {
    int notThird = 1; // counter to look for the 3rd book
    int cost = 0;
    for (int i = numBooks; i > 0; i--)
    {
      // Traverse through in ascending order so that they always get the most expensive book possible for free.
      if(notThird != 3)
      {
        cost+= bookList[i - 1]; // add each book
        notThird++;
      }
      else
      {
      notThird = 1; // We have reached the free book. Restart the count
      }
    }

    printf("%d", cost); // Print the output
  }



  void mergeSort(int values[], int start, int end)
  {
    int mid;
    if(start < end)
    {
      mid = (start + end) / 2;
      // divide by 2 for merge sort
      mergeSort(values, start, mid); 
      // Recursively call merge sort to create more groups to search through
      mergeSort(values, mid + 1, end);
      merge(values, start, mid + 1, end); // Merge each as it's being sorted
    }
  }
  
  void merge(int values[], int start, int middle, int end)
  {
    int *temp, i, length, count1, count2, mc;
    length = end - start + 1;
    temp = (int*)calloc(length, sizeof(int)); // alloc space for the array to be merged.
    //index in first list
    count1 = start;
    count2 = middle;
    mc = 0; // index in main array
    // Here we copy values into our auxiliary array, so long as there are numbers from both lists to copy.
    while ((count1 < middle) || (count2 <= end))
    {
      if (count2 > end || (count1 < middle && values[count1] < values[count2]))
      {
        // should it go into the first list or second list?
        temp[mc] = values[count1]; // copy values into the allocated array
        count1++;
        mc++;
      }
      else
      {
        temp[mc] = values[count2]; // copy valuefrom the second list
        count2++;
        mc++;
      }
    }
    for (i = start; i <= end; i++)
      values[i]=temp[i - start];
    
    free(temp); // free allocated space
  }
        </code>
      </pre>

      <!-- end tiny slot -->

    </div>
  </div>
  <!-- END PROJECT 5 -->
</div>

      </div>
      <!-- START content SNIPPET-->
        
      <!-- END content SNIPPET -->
      

    </div>
   <footer class="bg-transparent" aria-labelledby="footer-heading">
     <h2 id="footer-heading" class="sr-only">Footer</h2>
     <div class="mx-auto max-w-7xl py-12 px-6 lg:py-16 lg:px-8">
       <div class="mt-8 border-t border-gray-700 pt-8 md:flex md:items-center md:justify-center">
         <p class="mt-8 text-base text-gray-400 md:order-1 md:mt-0 text-center">&copy; 2023 Madison Manuel. All rights
           reserved.
         </p>
       </div>
     </div>
   </footer>
  </div>
</body>

</html>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/rainbow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
  hljs.highlightAll();
</script>

<style>
  /* stroke */
  nav.stroke ul li a,
  nav.fill ul li a {
    position: relative;
  }

  nav.stroke ul li a:after,
  nav.fill ul li a:after {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
    width: 0%;
    content: '.';
    color: transparent;
    background: #af8936;
    height: 1px;
  }

  nav.stroke ul li a:hover:after {
    width: 100%;
  }

  /* NAVIGATION 
  nav {
  width: 80%;
  margin: 0 auto;
  background: #fff;
  padding: 50px 0;
  box-shadow: 0px 5px 0px #dedede;
  } */

  /* nav ul li {
  display: inline-block;
  } */

  /*nav ul li a {

  mb:10px
  } */

  .code {
    font-family: Fira Code VF, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
  }

  nav ul li a,
  nav ul li a:after,
  nav ul li a:before {
    transition: all .5s;
  }

  nav ul li a:hover {
    color: #555;
  }
</style>
